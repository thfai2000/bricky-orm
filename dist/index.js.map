{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["// import { Builder } from './Builder'\nimport knex, { Knex } from 'knex'\nimport * as fs from 'fs';\n\n// let knexObj: Knex<any, unknown[]> | null = null\n// const getGlobalKnex = () => {\n//     if(!knexObj){\n//         knexObj = knex({\n//         client: 'mysql2',\n//             // connection: {\n//             //     host : '127.0.0.1',\n//             //     user : 'example',\n//             //     password : 'example',\n//             //     database : 'example'\n//             // }\n//         });\n//     }\n//     return knexObj\n// }\n\ntype Config = {\n    modelsPath: string,\n    dbSchemaPath: string,\n    entityNameToTableName?: (params:string) => string,\n    tableNameToEntityName?: (params:string) => string,\n    propNameTofieldName?: (params:string) => string,\n    fieldNameToPropName?: (params:string) => string,\n    \n}\n\nlet knexOption = {client: 'mysql2'}\n\nconst getKnexInstance = () => knex(knexOption)\n\nlet config: Config = {\n    modelsPath: 'models/',\n    dbSchemaPath: 'db-schema.sql'\n}\n\n\nconst types = {\n    AutoIncrement: ['bigint', 'NOT NULL', 'AUTO_INCREMENT', 'PRIMARY KEY'],\n    String: (length: number, nullable: boolean) => [`varchar(${length})`],\n    Number: ['integer'],\n    Date: ['datetime'],\n    arrayOf: function(entity: { new(): Entity }){\n        //TODO\n    }\n}\n\nexport const Types = types\n\nexport const More = {\n    Null: 'NULL',\n    NotNull: \"NOT NULL\"\n}\n\nlet schemas: any = {}\nexport class Schema {\n\n    tableName: string\n    entityName: string\n    fields: Field[]\n    primaryKey: Field\n\n    constructor(entityName: string){\n        this.entityName = entityName\n        this.tableName = config.entityNameToTableName?config.entityNameToTableName(entityName):entityName\n        this.primaryKey = {\n            name: 'id',\n            defination: [Types.AutoIncrement],\n            computed: false\n        }\n        this.fields = [this.primaryKey]\n    }\n\n    createTableStmt(){\n        return `CREATE TABLE \\`${this.tableName}\\` (\\n${this.fields.filter(f => !f.computed).map(f => `\\`${f.name}\\` ${f.defination.flat().join(' ')}`).join(',\\n')}\\n)`;\n    }\n\n\n    prop(name:string, defination: any, options?: any){\n        this.fields.push({\n            name,\n            defination,\n            ...options,\n            computed: false\n        })\n    }\n\n    computedProp(name:string, defination: any, options?: any){\n        this.fields.push({\n            name,\n            defination,\n            ...options,\n            computed: true\n        })\n    }\n\n}\n\n\nfunction makeid(length: number) {\n    var result           = [];\n    var characters       = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    var charactersLength = characters.length;\n    for ( var i = 0; i < length; i++ ) {\n      result.push(characters.charAt(Math.floor(Math.random() * \n charactersLength)));\n   }\n   return result.join('');\n}\n\n\ntype Field = {\n    name: string,\n    defination: any,\n    options?: any,\n    computed: boolean\n}\n\nexport const configure = async function(newConfig: Config){\n    config = newConfig\n\n    let files = fs.readdirSync(config.modelsPath)\n    let tables: Schema[] = []\n    \n    await Promise.all(files.map( async(file) => {\n        if(file.endsWith('.js')){\n            let path = config.modelsPath + '/' + file\n            path = path.replace(/\\.js$/,'')\n            console.log('load model file:', path)\n            let p = path.split('/')\n            let entityName = p[p.length - 1]\n            let entityClass = require(path)\n            if(entityClass.default.register){\n                let s = new Schema(entityName)\n                tables.push(s)\n                entityClass.default.register(s)\n                schemas[entityName] = s\n            }\n        }\n    }))\n    // let schemaFilename = new Date().getTime() + '.sql'\n    let path = config.dbSchemaPath //+ '/' + schemaFilename\n    fs.writeFileSync(path, tables.map(t => t.createTableStmt()).join(\";\\n\") + ';' )\n    console.log('schemas:', Object.keys(schemas))\n}\n\n\nexport const Select = function(...args: any[]){\n\n    let alias: string[] = args.map(s => /\\[\\[(.*)\\]\\]/g.exec(s)?.[1] || '' ).filter(s => s.length > 0)\n    \n    let info = alias.map(a => {\n        let parts = a.split('|')\n        return {\n            fullName: `[[${a}]]`,\n            tableName: parts[0],\n            aliasName: parts[1],\n            fieldName: parts[2]\n        }\n    })\n\n    let distinctNames: string[] = [...new Set(info.map(i => `${i.tableName} as ${i.aliasName}`))]\n    // let [firstName, ...otherNames] = distinctNames\n\n    let stmt = getKnexInstance().select(...args)\n    if(distinctNames.length === 1){\n        stmt = stmt.from(distinctNames[0])\n    }\n\n    // stmt = distinctNames.reduce((acc, name) => acc.from(name, {only:false}), stmt)\n    console.log(stmt.toSQL())\n    return stmt\n}\n\nSelect('[[SKU|t1|name]].name', '[[SKU|t1|abc]].abc')\n\ntype QueryBuilder = (stmt: Knex.QueryBuilder, map: object) => Knex.QueryBuilder\nexport class Entity {\n    constructor(){\n    }\n\n    static get schema(): Schema{\n        return schemas[this.name]\n    }\n\n    static get tableName() {\n        return this.schema.tableName\n    }\n\n    static belongsTo(entityClass: typeof Entity, propName: string){\n        let map = this.produceNameMap()\n        return getKnexInstance().from(`\\`${entityClass.tableName}\\` AS xxxx`).where(getKnexInstance().raw(\"?? = ??\", [propName, entityClass.schema.primaryKey.name]))\n    }\n\n    static hasMany(entityClass: typeof Entity, propName: string){\n\n    }\n\n    static produceNameMap(): object {\n        let randomName = makeid(5)\n        return this.schema.fields.reduce( (acc: any, f) => {\n            acc[f.name] = `${randomName}.${f.name}`\n            return acc\n        }, {\n            '_': `${this.schema.tableName} As ${randomName}`,\n            'all': `${randomName}.*`\n        })\n    }\n\n    static async get(func: QueryBuilder ){\n        let map: any = this.produceNameMap()\n        let stmt = getKnexInstance().from(map._)\n        stmt = func(stmt, map)\n        return stmt.toString()\n    }\n\n    static getOne(){\n\n    }\n\n    // it is a parser\n    static Array(){\n\n    }\n}"],
  "mappings": "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",
  "names": []
}

{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["// import { Builder } from './Builder'\nimport knex, { Knex } from 'knex'\nimport * as fs from 'fs';\nconst sqlParser = require('js-sql-parser');\n\ntype Config = {\n    modelsPath: string,\n    dbSchemaPath: string,\n    entityNameToTableName?: (params:string) => string,\n    tableNameToEntityName?: (params:string) => string,\n    propNameTofieldName?: (params:string) => string,\n    fieldNameToPropName?: (params:string) => string,\n    knexConfig: object\n}\n\n// the new orm config\nlet config: Config = {\n    modelsPath: 'models/',\n    dbSchemaPath: 'db-schema.sql',\n    knexConfig: {client: 'mysql2'}\n}\n\n// a global knex instance\nconst getKnexInstance = () => knex(config.knexConfig)\n\n\nconst types = {\n    AutoIncrement: ['bigint', 'NOT NULL', 'AUTO_INCREMENT', 'PRIMARY KEY'],\n    String: (length: number, nullable: boolean) => [`varchar(${length})`],\n    Number: ['integer'],\n    Date: ['datetime'],\n    arrayOf: function(entity: { new(): Entity }){\n        //TODO\n    }\n}\n\nexport const Types = types\n\nexport const More = {\n    Null: 'NULL',\n    NotNull: \"NOT NULL\"\n}\n\nlet schemas: any = {}\nexport class Schema {\n\n    tableName: string\n    entityName: string\n    properties: Property[]\n    primaryKey: Property\n\n    constructor(entityName: string){\n        this.entityName = entityName\n        this.tableName = config.entityNameToTableName?config.entityNameToTableName(entityName):entityName\n        this.primaryKey = {\n            name: 'id',\n            definition: [Types.AutoIncrement],\n            computedFunc: null\n        }\n        this.properties = [this.primaryKey]\n    }\n\n    createTableStmt(){\n        return `CREATE TABLE \\`${this.tableName}\\` (\\n${this.properties.filter(f => !f.computedFunc).map(f => `\\`${f.name}\\` ${f.definition.flat().join(' ')}`).join(',\\n')}\\n)`;\n    }\n\n\n    prop(name:string, definition: any, options?: any){\n        this.properties.push({\n            name,\n            definition,\n            ...options,\n            computedFunc: null\n        })\n    }\n\n    computedProp(name:string, definition: any, computedFunc: ComputedFunction){\n        this.properties.push({\n            name,\n            definition,\n            computedFunc\n        })\n    }\n\n}\n\n\nfunction makeid(length: number) {\n    var result           = [];\n    var characters       = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    var charactersLength = characters.length;\n    for ( var i = 0; i < length; i++ ) {\n      result.push(characters.charAt(Math.floor(Math.random() * \n charactersLength)));\n   }\n   return result.join('');\n}\n\ninterface ComputedFunctionResult{\n    toString(): string\n}\n\ntype ComputedFunction = (map: object, ...args: any[]) => ComputedFunctionResult\n\ntype Property = {\n    name: string,\n    definition: any,\n    options?: any,\n    computedFunc: ComputedFunction | null\n}\n\nexport const configure = async function(newConfig: Config){\n    config = newConfig\n\n    let files = fs.readdirSync(config.modelsPath)\n    let tables: Schema[] = []\n    \n    await Promise.all(files.map( async(file) => {\n        if(file.endsWith('.js')){\n            let path = config.modelsPath + '/' + file\n            path = path.replace(/\\.js$/,'')\n            console.log('load model file:', path)\n            let p = path.split('/')\n            let entityName = p[p.length - 1]\n            let entityClass = require(path)\n            if(entityClass.default.register){\n                let s = new Schema(entityName)\n                tables.push(s)\n                entityClass.default.register(s)\n                schemas[entityName] = s\n            }\n        }\n    }))\n    // let schemaFilename = new Date().getTime() + '.sql'\n    let path = config.dbSchemaPath //+ '/' + schemaFilename\n    fs.writeFileSync(path, tables.map(t => t.createTableStmt()).join(\";\\n\") + ';' )\n    console.log('schemas:', Object.keys(schemas))\n}\n\n\n\ntype QueryFunction = (stmt: Knex.QueryBuilder, map: object) => Knex.QueryBuilder\nexport class Entity {\n    constructor(){\n    }\n\n    static get schema(): Schema{\n        return schemas[this.name]\n    }\n\n    static get tableName() {\n        return this.schema.tableName\n    }\n\n    // create a basic belongsTo prepared statement (SQL template)\n    static belongsTo(entityClass: typeof Entity, propName: string){\n        let map = this.produceNameMap()\n        return getKnexInstance().from(map.$).where(getKnexInstance().raw(\"?? = ??\", [propName, map.$id]))\n    }\n\n    // create a basic belongsTo prepared statement (SQL template)\n    static hasMany(entityClass: typeof Entity, propName: string){\n        let map = entityClass.produceNameMap()\n        return getKnexInstance().from(map.$).where(getKnexInstance().raw(\"?? = ??\", [propName, map.$id]))\n    }\n\n    /**\n     * NameMap is very important. used for building sql part with actual field name\n     * field pointers\n     * @returns \n     */\n    static produceNameMap(): object {\n        let randomTblName = makeid(5)\n        let propNameTofieldName = config.propNameTofieldName ?? ((name) => name)\n        let map: object = {\n            $: `${this.schema.tableName} AS ${randomTblName}`,   // used as table name\n            $all: `${randomTblName}.*`,                          \n            $id : `${randomTblName}.${propNameTofieldName(this.schema.primaryKey.name)}`\n        }\n        this.schema.properties.forEach( (prop) => {\n            //convert the props name into actual field Name\n            let actualFieldName = propNameTofieldName(prop.name)\n            if(prop.computedFunc){\n                let func = prop.computedFunc\n                map[prop.name] = (...args: any[]) => {\n                    let subquery = func(map, ...args).toString()\n\n                    // determine the column list\n                    let ast = sqlParser.parse(subquery)\n                    //TODO: there will be bug if the alias contain . inside\n                    let columns: string[] = ast.value.selectItems.value.map( (v:any) => (v.alias? v.alias: v.value) ).map( (v:string) => {\n                        let p = v.split('.')\n                        let name = p[p.length - 1]\n                        return name\n                    })\n                    \n                    // FIX: more than one table has *\n                    if(columns.includes('*')){\n                        //replace star into all column names\n                        //TODO:\n                    }\n\n                    let jsonify =  `SELECT JSON_ARRAYAGG(JSON_OBJECT(${\n                        columns.map(c => `'${c.replace(/[`']/g,'')}', ${c}`).join(',')\n                    })) FROM (${subquery}) AS ${makeid(5)}`\n\n                    return getKnexInstance().raw('(' + jsonify + `) AS ${actualFieldName}`)\n                }\n            } else {\n                map[prop.name] = `${randomTblName}.${actualFieldName}`\n            }\n        })\n\n        return map\n    }\n\n    static async find(func: QueryFunction ){\n        let map: any = this.produceNameMap()\n        let stmt: Knex.QueryBuilder = getKnexInstance().from(map.$)\n        stmt = func(stmt, map)\n        console.log(\"========== FIND ================\")\n        console.log(stmt.toString())\n        console.log(\"================================\")\n        return await stmt\n    }\n\n    // it is a parser\n    static Array(){\n\n    }\n}\n\n\n/**\n * \n * \n *  Below is for experiment usage\n * \n * \n */\n\n// export const select = function(...args: any[]){\n\n//     let alias: string[] = args.map(s => /\\[\\[(.*)\\]\\]/g.exec(s)?.[1] || '' ).filter(s => s.length > 0)\n    \n//     let info = alias.map(a => {\n//         let parts = a.split('|')\n//         return {\n//             fullName: `[[${a}]]`,\n//             tableName: parts[0],\n//             aliasName: parts[1],\n//             fieldName: parts[2]\n//         }\n//     })\n\n//     let distinctNames: string[] = [...new Set(info.map(i => `${i.tableName} as ${i.aliasName}`))]\n//     // let [firstName, ...otherNames] = distinctNames\n\n//     let stmt = getKnexInstance().select(...args)\n//     if(distinctNames.length === 1){\n//         stmt = stmt.from(distinctNames[0])\n//     }\n\n//     // stmt = distinctNames.reduce((acc, name) => acc.from(name, {only:false}), stmt)\n//     console.log(stmt.toSQL())\n//     return stmt\n// }\n\n// select('[[SKU|t1|name]].name', '[[SKU|t1|abc]].abc')"],
  "mappings": "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",
  "names": []
}

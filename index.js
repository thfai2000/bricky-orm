/*! For license information please see index.js.LICENSE.txt */
var __create=Object.create,__defProp=Object.defineProperty,__getOwnPropDesc=Object.getOwnPropertyDescriptor,__getOwnPropNames=Object.getOwnPropertyNames,__getProtoOf=Object.getPrototypeOf,__hasOwnProp=Object.prototype.hasOwnProperty,__markAsModule=t=>__defProp(t,"__esModule",{value:!0}),__export=(t,e)=>{for(var r in __markAsModule(t),e)__defProp(t,r,{get:e[r],enumerable:!0})},__reExport=(t,e,r)=>{if(e&&"object"==typeof e||"function"==typeof e)for(let n of __getOwnPropNames(e))__hasOwnProp.call(t,n)||"default"===n||__defProp(t,n,{get:()=>e[n],enumerable:!(r=__getOwnPropDesc(e,n))||r.enumerable});return t},__toModule=t=>__reExport(__markAsModule(__defProp(null!=t?__create(__getProtoOf(t)):{},"default",t&&t.__esModule&&"default"in t?{get:()=>t.default,enumerable:!0}:{value:t,enumerable:!0})),t),__accessCheck=(t,e,r)=>{if(!e.has(t))throw TypeError("Cannot "+r)},__privateGet=(t,e,r)=>(__accessCheck(t,e,"read from private field"),r?r.call(t):e.get(t)),__privateAdd=(t,e,r)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,r)},__privateSet=(t,e,r,n)=>(__accessCheck(t,e,"write to private field"),n?n.call(t,r):e.set(t,r),r);__export(exports,{AndOperator:()=>AndOperator,ArrayType:()=>ArrayType,AssertionOperator:()=>AssertionOperator,AssertionOperatorWrapper:()=>AssertionOperatorWrapper,BetweenOperator:()=>BetweenOperator,BooleanNotNullType:()=>BooleanNotNullType,BooleanType:()=>BooleanType,ComputeFunction:()=>ComputeFunction2,ComputeFunctionDynamicReturn:()=>ComputeFunctionDynamicReturn2,ComputeProperty:()=>ComputeProperty,ConditionOperator:()=>ConditionOperator,DBActionRunnerBase:()=>DBActionRunnerBase,DBMutationRunner:()=>DBMutationRunner,DBQueryRunner:()=>DBQueryRunner,DScalar:()=>DScalar,DatabaseContext:()=>DatabaseContext4,Dataset:()=>Dataset2,DateNotNullType:()=>DateNotNullType,DateTimeNotNullType:()=>DateTimeNotNullType,DateTimeType:()=>DateTimeType,DateType:()=>DateType,DecimalNotNullType:()=>DecimalNotNullType,DecimalType:()=>DecimalType,DeleteStatement:()=>DeleteStatement,DerivedDatasource:()=>DerivedDatasource,DerivedTableSchema:()=>DerivedTableSchema,EqualOperator:()=>EqualOperator,ExistsOperator:()=>ExistsOperator,ExpressionResolver:()=>ExpressionResolver2,FieldProperty:()=>FieldProperty,FieldPropertyType:()=>FieldPropertyType,GreaterThanOperator:()=>GreaterThanOperator,GreaterThanOrEqualsOperator:()=>GreaterThanOrEqualsOperator,Hook:()=>Hook2,InOperator:()=>InOperator,InsertStatement:()=>InsertStatement,IsNotNullOperator:()=>IsNotNullOperator,IsNullOperator:()=>IsNullOperator,LeftAndRightAssertionOperator:()=>LeftAndRightAssertionOperator,LessThanOperator:()=>LessThanOperator,LessThanOrEqualsOperator:()=>LessThanOrEqualsOperator,LikeOperator:()=>LikeOperator,Model:()=>Model,ModelRepository:()=>ModelRepository,NotBetweenOperator:()=>NotBetweenOperator,NotEqualOperator:()=>NotEqualOperator,NotInOperator:()=>NotInOperator,NotLikeOperator:()=>NotLikeOperator,NotOperator:()=>NotOperator,NumberNotNullType:()=>NumberNotNullType,NumberType:()=>NumberType,ORM:()=>ORM,ObjectType:()=>ObjectType,OrOperator:()=>OrOperator,ParsablePropertyTypeDefinition:()=>ParsablePropertyTypeDefinition,PrimaryKeyType:()=>PrimaryKeyType,Property:()=>Property,PropertyType:()=>PropertyType,Scalar:()=>Scalar,ScalarProperty:()=>ScalarProperty,Schema:()=>Schema,SimpleObjectClass:()=>SimpleObjectClass,StringNotNullType:()=>StringNotNullType,StringType:()=>StringType,TableDatasource:()=>TableDatasource,TableSchema:()=>TableSchema,UpdateStatement:()=>UpdateStatement,camelize:()=>camelize,constructSqlKeywords:()=>constructSqlKeywords,expand:()=>expand,expandRecursively:()=>expandRecursively,isArrayOfStrings:()=>isArrayOfStrings,isFunction:()=>isFunction,isScalarMap:()=>isScalarMap,makeid:()=>makeid,notEmpty:()=>notEmpty,parseName:()=>parseName,quote:()=>quote,resolveValueIntoScalar:()=>resolveValueIntoScalar,thenResult:()=>thenResult,thenResultArray:()=>thenResultArray,undoExpandRecursively:()=>undoExpandRecursively});var import_knex=__toModule(require("knex")),fs=__toModule(require("fs"));function undoExpandRecursively(t){return t}function expandRecursively(t){return t}function expand(t){return t}var SimpleObjectClass={}.constructor;function notEmpty(t){return null!=t}function thenResultArray(t,e,r){if(!Array.isArray(t))throw new Error("It is not an array");return t.some((t=>t instanceof Promise))?Promise.all(t).then(e,r):e(t)}function thenResult(t,e,r){return t instanceof Promise?t.then(e,r):e(t)}var quote=(t,e)=>{const r=t;if(r.startsWith("sqlite")||r.startsWith("mysql"))return`\`${e.replace(/`/g,"``")}\``;if(r.startsWith("pg"))return`"${e.replace(/"/g,'""')}"`;throw new Error("Unsupport client")};function camelize(t){return t.replace(/(?:^\w|[A-Z]|\b\w)/g,(function(t,e){return 0===e?t.toLowerCase():t.toUpperCase()})).replace(/\s+/g,"")}function makeid(t){const e=[],r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890",n=r.length;for(let s=0;s<t;s++)e.push(r.charAt(Math.floor(Math.random()*n)));return e.join("")}var parseName=t=>{const e=t.toString().trim(),r=/((?<![\\])[`'"])((?:.(?!(?<![\\])\1))*.?)\1/g;let n=r.exec(e);if(n){let t=n[0];for(;n=r.exec(e);)t=n[0];return t}{const t=/\b[. ]+([a-zA-Z0-9_$]*)$/.exec(e);return t&&t[1]?t[1]:e}};function isFunction(t){const e=Object.getOwnPropertyNames(t);return!e.includes("prototype")||e.includes("arguments")}function isArrayOfStrings(t){return t.every((t=>"string"==typeof t))}function isScalarMap(t){if("object"==typeof t){const e=Object.keys(t);for(const r in e)if(t[e[r]]instanceof Scalar)return!0}return!1}var _func,_name,nullableText=t=>t?"NULL":"NOT NULL",autoIncrement=t=>t.startsWith("sqlite")?"AUTOINCREMENT":"AUTO_INCREMENT",jsonArrayAgg=t=>{if(t.startsWith("sqlite"))return"JSON_GROUP_ARRAY";if(t.startsWith("mysql"))return"JSON_ARRAYAGG";if(t.startsWith("pg"))return"JSON_AGG";throw new Error("NYI")},jsonArray=(t,e=[])=>{if(t.startsWith("sqlite"))return`JSON_ARRAY(${e.join(",")})`;if(t.startsWith("mysql"))return`JSON_ARRAY(${e.join(",")})`;if(t.startsWith("pg"))return`JSON_BUILD_ARRAY(${e.join(",")})`;throw new Error("NYI")},PropertyType=class{constructor(t){this.options={},this.options=this.options??t}get nullable(){return!0}async prepareForParsing(t){}parseRaw(t,e,r){return t}parseProperty(t,e,r){return t}transformQuery(t,e,r){if(t instanceof Dataset2){if(1===t.selectItemsAlias().length)return thenResult(t.toNativeBuilder(e),(t=>e.raw(`(${t})`)));throw new Error("Only Dataset with single column can be transformed.")}return t}},FieldPropertyType=class extends PropertyType{constructor(t){super(t)}},ParsablePropertyTypeDefinition=class extends PropertyType{constructor(t){super(t)}},PrimaryKeyType=class extends FieldPropertyType{constructor(t){super(t)}get nullable(){return!1}create(t,e,r){const n=r.client();return n.startsWith("pg")?[[`${quote(n,e)}`,"SERIAL",nullableText(!1),"PRIMARY KEY"].join(" ")]:[[`${quote(n,e)}`,"INTEGER",nullableText(!1),"PRIMARY KEY",autoIncrement(n)].join(" ")]}},NumberType=class extends FieldPropertyType{constructor(t={}){super(t),this.options=t}get nullable(){return!0}parseRaw(t){return null===t?null:parseInt(t)}create(t,e,r){const n=r.client();return[[`${quote(n,e)}`,"INTEGER",nullableText(this.nullable),void 0!==this.options?.default?`DEFAULT ${this.options?.default}`:""].join(" ")]}},NumberNotNullType=class extends FieldPropertyType{constructor(t={}){super(t),this.options=t}get nullable(){return!1}parseRaw(t){if(null===t)throw new Error("Cannot null");return parseInt(t)}create(t,e,r){const n=r.client();return[[`${quote(n,e)}`,"INTEGER",nullableText(this.nullable),void 0!==this.options?.default?`DEFAULT ${this.options?.default}`:""].join(" ")]}},DecimalType=class extends FieldPropertyType{constructor(t={}){super(),this.options={...t}}get nullable(){return!0}parseRaw(t){return null===t?null:parseFloat(t)}create(t,e,r){const n=r.client(),s=[this.options.precision,this.options.scale].filter((t=>t)).join(",");return[[`${quote(n,e)}`,"DECIMAL"+(s.length>0?`(${s})`:""),nullableText(this.nullable),void 0!==this.options?.default?`DEFAULT ${this.options?.default}`:""].join(" ")]}},DecimalNotNullType=class extends FieldPropertyType{constructor(t={}){super(),this.options={...t}}get nullable(){return!1}parseRaw(t){if(null===t)throw new Error("value should not be null");return parseFloat(t)}create(t,e,r){const n=r.client(),s=[this.options.precision,this.options.scale].filter((t=>t)).join(",");return[[`${quote(n,e)}`,"DECIMAL"+(s.length>0?`(${s})`:""),nullableText(this.nullable),void 0!==this.options?.default?`DEFAULT ${this.options?.default}`:""].join(" ")]}},BooleanType=class extends FieldPropertyType{constructor(t={}){super(),this.options={...t}}get nullable(){return!0}parseRaw(t,e,r){if(null===t)return null;if(!0===t)return!0;if(!1===t)return!1;if(Number.isInteger(t))return parseInt(t)>0;throw new Error("Cannot parse Raw into Boolean")}parseProperty(t,e,r){if(null===t&&!this.nullable)throw new Error(`The Property '${r}' cannot be null.`);return e.client().startsWith("pg")?null===t?null:!!t:null===t?null:t?"1":"0"}create(t,e,r){const n=r.client();return[[`${quote(n,e)}`,n.startsWith("pg")?"BOOLEAN":"TINYINT(1)",nullableText(this.nullable),void 0!==this.options?.default?`DEFAULT ${this.options?.default}`:""].join(" ")]}},BooleanNotNullType=class extends FieldPropertyType{constructor(t={}){super(),this.options={...t}}get nullable(){return!0}parseRaw(t,e,r){if(null===t)throw new Error("Not expected null");if(!0===t)return!0;if(!1===t)return!1;if(Number.isInteger(t))return parseInt(t)>0;throw new Error("Cannot parse Raw into Boolean")}parseProperty(t,e,r){if(null===t&&!this.nullable)throw new Error(`The Property '${r}' cannot be null.`);return e.client().startsWith("pg")?null===t?null:!!t:null===t?null:t?"1":"0"}create(t,e,r){const n=r.client();return[[`${quote(n,e)}`,n.startsWith("pg")?"BOOLEAN":"TINYINT(1)",nullableText(this.nullable),void 0!==this.options?.default?`DEFAULT ${this.options?.default}`:""].join(" ")]}},StringType=class extends FieldPropertyType{constructor(t={}){super(),this.options={...t}}get nullable(){return!0}create(t,e,r){const n=r.client();let s=this.options.length;n.startsWith("mysql")&&(s||(s=255));const a=[s].filter((t=>t)).join(",");return[[`${quote(n,e)}`,"VARCHAR"+(a.length>0?`(${a})`:""),nullableText(this.nullable),void 0!==this.options?.default?`DEFAULT ${this.options?.default}`:""].join(" ")]}},StringNotNullType=class extends FieldPropertyType{constructor(t={}){super(),this.options={...t}}get nullable(){return!1}create(t,e,r){const n=r.client();let s=this.options.length;n.startsWith("mysql")&&(s||(s=255));const a=[s].filter((t=>t)).join(",");return[[`${quote(n,e)}`,"VARCHAR"+(a.length>0?`(${a})`:""),nullableText(this.nullable),void 0!==this.options?.default?`DEFAULT ${this.options?.default}`:""].join(" ")]}},DateType=class extends FieldPropertyType{constructor(t={}){super(),this.options={...t}}get nullable(){return!0}parseRaw(t){return null===t?null:new Date(t)}parseProperty(t,e,r){if(null===t&&!this.nullable)throw new Error(`The Property '${r}' cannot be null.`);return t}create(t,e,r){const n=r.client();return[[`${quote(n,e)}`,"DATE",nullableText(this.nullable),void 0!==this.options?.default?`DEFAULT ${this.parseProperty(this.options?.default,r)}`:""].join(" ")]}},DateNotNullType=class extends FieldPropertyType{constructor(t={}){super(),this.options={...t}}get nullable(){return!1}parseRaw(t){if(null===t)throw new Error("Unexpected null value");return new Date(t)}parseProperty(t,e,r){if(null===t&&!this.nullable)throw new Error(`The Property '${r}' cannot be null.`);return t}create(t,e,r){const n=r.client();return[[`${quote(n,e)}`,"DATE",nullableText(this.nullable),void 0!==this.options?.default?`DEFAULT ${this.parseProperty(this.options?.default,r)}`:""].join(" ")]}},DateTimeType=class extends FieldPropertyType{constructor(t={}){super(),this.options={...t}}get nullable(){return!0}parseRaw(t){return null===t?null:new Date(t)}parseProperty(t,e,r){if(null===t&&!this.nullable)throw new Error(`The Property '${r}' cannot be null.`);return t}create(t,e,r){const n=r.client(),s=[this.options.precision].filter((t=>t)).join(",");return[[`${quote(n,e)}`,n.startsWith("pg")?"TIMESTAMP"+(s.length>0?`(${s})`:""):"DATETIME"+(s.length>0?`(${s})`:""),nullableText(this.nullable),void 0!==this.options?.default?`DEFAULT ${this.parseProperty(this.options?.default,r,t)}`:""].join(" ")]}},DateTimeNotNullType=class extends FieldPropertyType{constructor(t={}){super(),this.options={...t}}get nullable(){return!1}parseRaw(t){return new Date(t)}parseProperty(t,e,r){if(null===t&&!this.nullable)throw new Error(`The Property '${r}' cannot be null.`);return t}create(t,e,r){const n=r.client(),s=[this.options.precision].filter((t=>t)).join(",");return[[`${quote(n,e)}`,n.startsWith("pg")?"TIMESTAMP"+(s.length>0?`(${s})`:""):"DATETIME"+(s.length>0?`(${s})`:""),nullableText(this.nullable),void 0!==this.options?.default?`DEFAULT ${this.parseProperty(this.options?.default,r,t)}`:""].join(" ")]}},ObjectType=class extends ParsablePropertyTypeDefinition{constructor(t){super(),this.parsable=t}get nullable(){return!0}async prepareForParsing(t){await super.prepareForParsing(t),await this.parsable.prepareForParsing(t)}transformQuery(t,e,r){if(!(t instanceof Dataset2))throw new Error("Only Dataset can be the type of 'ObjectOfEntity'");const n=t.selectItemsAlias(),s=this.parsable.columnsForParsing();if(s.some((t=>!n.includes(t))))throw new Error("Dataset selected column cannot be parsed. Missing Selected Items.");return thenResult(t.toNativeBuilder(e),(t=>{const r=e.client(),n=`SELECT ${jsonArray(r,s.map((t=>quote(r,t))))} AS ${quote(r,"data")} FROM (${t}) AS ${quote(r,makeid(5))}`;return e.raw(`(${n})`)}))}parseRaw(t,e,r){if(null===t)return t;{let r=null;if("string"==typeof t?r=JSON.parse(t):Array.isArray(t)&&(r=t),Array.isArray(r)){const t=this.parsable.columnsForParsing(),n=r,s=t.length,a=this.parsable,i={};for(let e=0;e<s;e++)i[t[e]]=n[e];return a.parseRaw(i,e)}}throw new Error("It is not supported.")}parseProperty(t,e,r){return this.parsable.parseProperty(t,e)}},ArrayType=class extends ParsablePropertyTypeDefinition{constructor(t){super(),this.parsable=t}get nullable(){return!0}async prepareForParsing(t){await super.prepareForParsing(t),await this.parsable.prepareForParsing(t)}transformQuery(t,e,r){if(!(t instanceof Dataset2))throw new Error("Only Dataset can be the type of 'ObjectOfEntity'");const n=t.selectItemsAlias(),s=this.parsable.columnsForParsing();if(s.some((t=>!n.includes(t))))throw new Error("Dataset selected column cannot be parsed. Missing Selected Items.");return thenResult(t.toNativeBuilder(e),(t=>{const r=e.client(),n=`SELECT coalesce(${jsonArrayAgg(r)}(${jsonArray(r,s.map((t=>quote(r,t))))}), ${jsonArray(r)}) AS ${quote(r,"data")} FROM (${t}) AS ${quote(r,makeid(5))}`;return e.raw(`(${n})`)}))}parseRaw(t,e,r){if(null===t)return t;{let r=null;if("string"==typeof t?r=JSON.parse(t):Array.isArray(t)&&(r=t),Array.isArray(r)){const t=this.parsable.columnsForParsing(),n=r,s=t.length,a=n.length,i=this.parsable,o=new Array(a);for(let r=0;r<a;r++){const a={};for(let e=0;e<s;e++)a[t[e]]=n[r][e];o[r]=i.parseRaw(a,e)}return o}}throw new Error("It is not supported.")}parseProperty(t,e,r){return this.parsable.parseProperty(t,e)}},ConditionOperator=class{constructor(t,e){this.context=t,this.resolver=e}getContext(){return this.context}toSqlString(t){return this.toScalar().toRaw(t??this.getContext()??void 0).toString()}},AssertionOperator=class{toSqlString(t){return this.toScalar().toRaw(t??this.getContext()??void 0).toString()}},LeftAndRightAssertionOperator=class extends AssertionOperator{constructor(t,e,...r){super(),this.context=t,this.rightOperands=r,this.leftOperand=e}getContext(){return this.context}toScalar(){return new Scalar((t=>thenResultArray(this.rightOperands.map((e=>resolveValueIntoScalar(e).toRaw(t))),(e=>thenResult(resolveValueIntoScalar(this.leftOperand).toRaw(t),(r=>this.leftAndRightToRaw(t,r,...e)))))),new BooleanNotNullType)}},AndOperator=class extends ConditionOperator{constructor(t,e,...r){super(t,e),this.args=r}toScalar(){return new Scalar((t=>0===this.args.length?t.raw("1"):thenResultArray(this.args.map((e=>this.resolver.resolve(e).toRaw(t))),(e=>t.raw(e.join(" AND "))))),new BooleanNotNullType)}},OrOperator=class extends ConditionOperator{constructor(t,e,...r){super(t,e),this.args=r}toScalar(){return new Scalar((t=>0===this.args.length?t.raw("1"):thenResultArray(this.args.map((e=>this.resolver.resolve(e).toRaw(t))),(e=>t.raw(e.join(" OR "))))),new BooleanNotNullType)}},NotOperator=class extends ConditionOperator{constructor(t,e,r){super(t,e),this.arg=r}toScalar(){return new Scalar((t=>thenResult(this.resolver.resolve(this.arg).toRaw(t),(e=>t.raw(`NOT (${e.toString()})`)))),new BooleanNotNullType)}},ExistsOperator=class extends ConditionOperator{constructor(t,e,r){super(t,e),this.arg=r}toScalar(){return new Scalar((t=>thenResult(this.arg.toNativeBuilder(t),(e=>t.raw(`EXISTS (${e.toString()})`)))),new BooleanNotNullType)}},InOperator=class extends LeftAndRightAssertionOperator{leftAndRightToRaw(t,e,...r){return t.raw(`${e} IN (${r.map((t=>"?"))})`,[...r])}},NotInOperator=class extends LeftAndRightAssertionOperator{leftAndRightToRaw(t,e,...r){return t.raw(`${e} NOT IN (${r.map((t=>"?"))})`,[...r])}},LikeOperator=class extends LeftAndRightAssertionOperator{constructor(t,e,r){super(t,e,r)}leftAndRightToRaw(t,e,...r){return t.raw(`${e} LIKE ?`,[r[0]])}},NotLikeOperator=class extends LeftAndRightAssertionOperator{constructor(t,e,r){super(t,e,r)}leftAndRightToRaw(t,e,...r){return t.raw(`${e} NOT LIKE ?`,[r[0]])}},EqualOperator=class extends LeftAndRightAssertionOperator{constructor(t,e,r){super(t,e,r)}leftAndRightToRaw(t,e,...r){return t.raw(`${e} = ?`,[r[0]])}},NotEqualOperator=class extends LeftAndRightAssertionOperator{constructor(t,e,r){super(t,e,r)}leftAndRightToRaw(t,e,...r){return t.raw(`${e} <> ?`,[r[0]])}},IsNullOperator=class extends LeftAndRightAssertionOperator{constructor(t,e){super(t,e)}leftAndRightToRaw(t,e){return t.raw(`${e} IS NULL`)}},IsNotNullOperator=class extends LeftAndRightAssertionOperator{constructor(t,e){super(t,e)}leftAndRightToRaw(t,e){return t.raw(`${e} IS NOT NULL`)}},GreaterThanOperator=class extends LeftAndRightAssertionOperator{constructor(t,e,r){super(t,e,r)}leftAndRightToRaw(t,e,...r){return t.raw(`${e} > ?`,[r[0]])}},LessThanOperator=class extends LeftAndRightAssertionOperator{constructor(t,e,r){super(t,e,r)}leftAndRightToRaw(t,e,...r){return t.raw(`${e} < ?`,[r[0]])}},GreaterThanOrEqualsOperator=class extends LeftAndRightAssertionOperator{constructor(t,e,r){super(t,e,r)}leftAndRightToRaw(t,e,...r){return t.raw(`${e} >= ?`,[r[0]])}},LessThanOrEqualsOperator=class extends LeftAndRightAssertionOperator{constructor(t,e,r){super(t,e,r)}leftAndRightToRaw(t,e,...r){return t.raw(`${e} <= ?`,[r[0]])}},BetweenOperator=class extends LeftAndRightAssertionOperator{constructor(t,e,r,n){super(t,e,r,n)}leftAndRightToRaw(t,e,...r){return t.raw(`${e} BETWEEN ? AND ?`,[r[0],r[1]])}},NotBetweenOperator=class extends LeftAndRightAssertionOperator{constructor(t,e,r,n){super(t,e,r,n)}leftAndRightToRaw(t,e,...r){return t.raw(`${e} NOT BETWEEN ? AND ?`,[r[0],r[1]])}},AssertionOperatorWrapper=class{constructor(t){__privateAdd(this,_func,void 0),__privateSet(this,_func,t)}toScalar(t){return __privateGet(this,_func).call(this,t).toScalar()}};function constructSqlKeywords(t,e=null){return{And:(...r)=>new AndOperator(e,t,...r).toScalar(),Or:(...r)=>new OrOperator(e,t,...r).toScalar(),Not:r=>new NotOperator(e,t,r).toScalar(),Exists:r=>new ExistsOperator(e,t,r).toScalar(),Like:t=>new AssertionOperatorWrapper((r=>new LikeOperator(e,r,resolveValueIntoScalar(t)))),NotLike:t=>new AssertionOperatorWrapper((r=>new NotLikeOperator(e,r,resolveValueIntoScalar(t)))),Now:()=>new Scalar((t=>t.client().startsWith("sqlite")?{sql:"strftime('%s','now')"}:{sql:"NOW()"}),DateTimeNotNullType),Case:(e,r,n)=>new Scalar((()=>{if(0===r.length)throw new Error("There must be at least one When case");return{sql:` CASE ? ${r.map((t=>"WHEN ? THEN ?")).join(" ")} ELSE ? END `,args:[t.resolve(e),...r.flatMap((e=>[t.resolve(e.when),t.resolve(e.then)])),t.resolve(n)]}})),If:(t,e,r)=>new Scalar((n=>n.$.Case(t,[{when:!0,then:e}],r)))}}_func=new WeakMap;var Property=class{constructor(){__privateAdd(this,_name,void 0)}register(t){if(/[.`' ]/.test(t)||t.startsWith("_")||t.endsWith("_"))throw new Error(`The name '${t}' of the NamedProperty is invalid. It cannot contains "'" or startsWith/endsWith '_'.`);__privateSet(this,_name,t)}get name(){if(!__privateGet(this,_name))throw new Error("Property not yet registered");return __privateGet(this,_name)}};_name=new WeakMap;var _definitionConstructor,_definition,ComputeProperty=class extends Property{constructor(t){super(),this.compute=t}async prepareForParsing(t){}},FieldProperty=class extends Property{constructor(t){super(),__privateAdd(this,_definitionConstructor,void 0),__privateAdd(this,_definition,null),__privateSet(this,_definitionConstructor,t)}get definition(){if(!__privateGet(this,_definition)){let t=null;if(__privateGet(this,_definitionConstructor)instanceof PropertyType?t=__privateGet(this,_definitionConstructor):isFunction(__privateGet(this,_definitionConstructor))?t=__privateGet(this,_definitionConstructor).call(this):__privateGet(this,_definitionConstructor)instanceof Function&&(t=new(__privateGet(this,_definitionConstructor))),!(t instanceof PropertyType))throw new Error("Invalid parameters");__privateSet(this,_definition,t)}return __privateGet(this,_definition)}async prepareForParsing(t){await this.definition.prepareForParsing(t)}convertFieldName(t,e){const r=e.ormConfig.propNameTofieldName;return r?r(t):t}fieldName(t){return this._fieldName?this._fieldName:this.convertFieldName(this.name,t)}setFieldName(t){return this._fieldName=t,this}};_definitionConstructor=new WeakMap,_definition=new WeakMap;var _entityName,ScalarProperty=class extends Property{constructor(t){super(),this.scalar=t}async prepareForParsing(t){await(await this.scalar.getDefinition(t)).prepareForParsing(t)}},Schema=class{constructor(t){this.properties=[],this.propertiesMap={},Object.keys(t).forEach((e=>{const r=t[e];if(!(r instanceof Property))throw new Error("Not expected");r.register(e),this.propertiesMap[e]=r,this.properties.push(r)}))}columnsForParsing(){return this.properties.map((t=>t.name))}async prepareForParsing(t){await Promise.all(this.properties.map((async e=>{await e.prepareForParsing(t)})))}parseRaw(t,e,r){return this.parseDataBySchema(t,e)}parseProperty(t,e,r){return t}parseDataBySchema(t,e){const r=this,n={};for(const s in t){const a=r.propertiesMap[s];if(a&&a instanceof ScalarProperty){const r=a.scalar.definitionForParsing(),i=r.parseRaw?r.parseRaw(t[s],e,s):t[s];Object.defineProperty(n,s,{configurable:!0,enumerable:!0,writable:!0,value:i})}}return n}},DerivedTableSchema=class extends Schema{constructor(t){const e=t.selectItems();if(!e)throw new Error("No selectItems for a schema");super(Object.keys(e).reduce(((t,r)=>(t[r]=new ScalarProperty(e[r]),t)),{})),this.dataset=t}datasource(t){return new DerivedDatasource(this.dataset,t)}},TableSchema=class extends Schema{constructor(t,e,r){super(e),this.hooks=[],__privateAdd(this,_entityName,void 0),__privateSet(this,_entityName,t),this.id=r}tableName(t,e){if(this.overridedTableName)return this.overridedTableName;{let r=__privateGet(this,_entityName);return t.orm.ormConfig.entityNameToTableName&&(r=t.orm.ormConfig.entityNameToTableName(r)),e?.tablePrefix?r=e.tablePrefix+r:t.config?.tablePrefix&&(r=t.config?.tablePrefix+r),r}}setTableName(t){return this.overridedTableName=t,this}createTableStmt(t,e){const r=t.client(),n=this.tableName(t,e),s=this.properties.filter((t=>t instanceof FieldProperty));return`CREATE TABLE IF NOT EXISTS ${quote(r,n)} (\n${s.map((e=>{const r=e.definition;return r instanceof FieldPropertyType?`${r.create(e.name,e.fieldName(t.orm),t)}`:""})).join(",\n")}\n)`}datasource(t,e){return new TableDatasource(this,t,e)}};_entityName=new WeakMap;var _selectItems,_orderByItems,_groupByItems,_limit,_offset,_insertIntoSchema,_insertItems,DatasourceBase=class{constructor(t,e){if(!Number.isInteger(e.charAt(0))&&e.charAt(0).toUpperCase()===e.charAt(0))throw new Error("alias cannot start with Uppercase letter");this._schema=t,this.sourceAlias=e,this.sourceAliasAndSalt=makeid(5);const r=this;this.$=new Proxy(r,{get:(t,e)=>{if("string"==typeof e){if("$allFields"===e)return r.getAllFieldProperty();{const n=t._schema.propertiesMap[e];if(n instanceof FieldProperty)return r.getFieldProperty(e);if(n instanceof ComputeProperty)return r.getComputeProperty(e);if(n instanceof ScalarProperty)return r.getScalarProperty(e)}}}})}schema(){return this._schema}getAllFieldProperty(){return Object.keys(this._schema.propertiesMap).reduce(((t,e)=>(this._schema.propertiesMap[e]instanceof FieldProperty&&(t[e]=this.getFieldProperty(e)),t)),{})}getFieldProperty(t){const e=this._schema.propertiesMap[t];if(e instanceof FieldProperty){const t=e;return new Scalar((e=>{const r=e.orm,n=e.client(),s=`${quote(n,this.sourceAliasAndSalt)}.${quote(n,t.fieldName(r))}`;return e.raw(s)}),t.definition)}throw new Error(`it is not field property ${t}`)}getComputeProperty(t){const e=this._schema.propertiesMap[t];if(e instanceof ComputeProperty){const t=e;return e=>t.compute.fn.call(t,this,e)}throw new Error(`Not field property ${t}`)}getScalarProperty(t){const e=this._schema.propertiesMap[t];if(e instanceof ScalarProperty)return new Scalar(e.scalar,null);throw new Error(`it is not field property ${t}`)}async toRaw(t){const e=t.client(),r=await this.realSource(t);return t.raw(`${r} AS ${quote(e,this.sourceAliasAndSalt)}`)}},TableDatasource=class extends DatasourceBase{constructor(t,e,r){super(t,e),this.options=r}schema(){return this._schema}realSource(t){const e=Object.assign({},{tablePrefix:t.tablePrefix},this.options??{}),r=this.schema().tableName(t,e);if(!r)throw new Error("Not yet registered");return quote(t.client(),r)}},DerivedDatasource=class extends DatasourceBase{constructor(t,e){super(t.schema(),e),this.dataset=t}async realSource(t){return`(${await this.dataset.toNativeBuilder(t)})`}},StatementBase=class{constructor(t){this.context=null,this.context=t}async scalarMap2RawMap(t,e,r){return r.client(),await Object.keys(e).reduce((async(n,s)=>{const a=await n,i=t.propertiesMap[s];if(i instanceof FieldProperty){const t=e[s];if(!t)throw new Error(`cannot resolve field ${s}`);let n=(await t.toRaw(r)).toString().trim();!n.includes(" ")||n.startsWith("(")&&n.endsWith(")")||(n=`(${n})`),a[i.fieldName(r.orm)]=r.raw(n)}return a}),Promise.resolve({}))}},WhereClauseBase=class extends StatementBase{constructor(){super(...arguments),this.fromItem=void 0,this.joinItems=[],this.whereRawItem=void 0}getSelectorMap(){const t=this.joinItems.map((t=>t.source));return this.fromItem&&t.push(this.fromItem),t.reduce(((t,e)=>(t[e.sourceAlias]=e.$,t)),{})}getFrom(){return this.fromItem}getWhere(){return this.whereRawItem}baseWhere(t){return this.whereRawItem=t,this}baseFrom(t){return this.fromItem=t,this}baseInnerJoin(t,e){return this.joinItems.push({type:"inner",source:t,expression:e}),this}baseLeftJoin(t,e){return this.joinItems.push({type:"left",source:t,expression:e}),this}baseRightJoin(t,e){return this.joinItems.push({type:"right",source:t,expression:e}),this}async buildWhereClause(t,e){const r=this.getSelectorMap(),n=new ExpressionResolver2(r,this.fromItem,this.joinItems.map((t=>t.source)));if(Object.assign(r,constructSqlKeywords(n,this.context)),await this.joinItems.reduce((async(r,s)=>{await r;const a=await n.resolve(s.expression).toRaw(t);return"inner"===s.type?e.innerJoin(await s.source.toRaw(t),a):"left"===s.type?e.leftJoin(await s.source.toRaw(t),a):"right"===s.type&&e.rightJoin(await s.source.toRaw(t),a),!0}),Promise.resolve(!0)),this.whereRawItem){const r=await n.resolve(this.whereRawItem).toRaw(t);e.where(r)}}cloneFrom(t){this.fromItem=t.fromItem,this.joinItems=t.joinItems,this.whereRawItem=t.whereRawItem}},Dataset2=class extends WhereClauseBase{constructor(t){super(t),this.datasetSchema=null,__privateAdd(this,_selectItems,null),__privateAdd(this,_orderByItems,null),__privateAdd(this,_groupByItems,null),__privateAdd(this,_limit,null),__privateAdd(this,_offset,null),this.nativeBuilderCallbacks=[],this.context=t??null}func2ScalarMap(t){let e;const r=this.getSelectorMap(),n=new ExpressionResolver2(r,this.fromItem,this.joinItems.map((t=>t.source)));if(t instanceof Function){Object.assign(r,constructSqlKeywords(n,this.context));const s=Object.assign({},this.getSelectorMap(),constructSqlKeywords(n,this.context));e=t(s)}else e=t;return Object.keys(e).reduce(((t,r)=>(t[r]=n.resolve(e[r]),t)),{})}func2ScalarArray(t){let e;const r=this.getSelectorMap(),n=new ExpressionResolver2(r,this.fromItem,this.joinItems.map((t=>t.source)));return t instanceof Function?(Object.assign(r,constructSqlKeywords(n,this.context)),e=t(Object.assign({},this.getSelectorMap(),constructSqlKeywords(n,this.context)))):e=t,e}func2OrderItemArray(t){let e;const r=this.getSelectorMap(),n=new ExpressionResolver2(r,this.fromItem,this.joinItems.map((t=>t.source)));return t instanceof Function?(Object.assign(r,constructSqlKeywords(n,this.context)),e=t(Object.assign({},this.getSelectorMap(),constructSqlKeywords(n,this.context)))):e=t,e.map((t=>{if(t instanceof Scalar)return{value:t,order:"asc"};if("string"==typeof t){const e=this.propNameArray2ScalarMap([t]);return{value:Object.values(e)[0],order:"asc"}}{const e=t;if("string"==typeof e.value){const t=this.propNameToScalar(r,e.value);return{value:Object.values(t)[0],order:e.order}}if(e.value instanceof Scalar)return{value:e.value,order:e.order};throw new Error("Not allowed")}}))}propNameToScalar(t,e){const r=t;let[n,s]=e.split("."),a=null;if(s)a=r[n][s];else{if(s=n,!this.fromItem)throw new Error("There must be a FROM");a=this.fromItem.$[s]}if(a)return a instanceof Scalar?{[s]:a}:{[s]:a()};throw new Error(`Cannot resolve field ${e}`)}propNameArray2ScalarMap(t){const e=this.getSelectorMap();return t.reduce(((t,r)=>{const n=this.propNameToScalar(e,r);return Object.assign({},t,n)}),{})}async queryScalarMap2RawArray(t,e,r){const n=e.client();return await Promise.all(Object.keys(t).map((async s=>{const a=t[s];if(!a)throw new Error(`cannot resolve field ${s}`);let i=(await a.toRaw(e)).toString().trim();return!i.includes(" ")||i.startsWith("(")&&i.endsWith(")")||(i=`(${i})`),e.raw(`${i}${r?` AS ${quote(n,s)}`:""}`)})))}async queryScalarArray2RawArray(t,e){return e.client(),await Promise.all(t.map((async t=>{const r=t;if(!r)throw new Error(`cannot resolve field ${t}`);let n=(await r.toRaw(e)).toString().trim();return!n.includes(" ")||n.startsWith("(")&&n.endsWith(")")||(n=`(${n})`),e.raw(`${n}`)})))}async orderByScalarArray2RawArray(t,e){return e.client(),await Promise.all(t.map((async t=>{const r=t;if(!r)throw new Error(`cannot resolve field ${t}`);let n=(await r.value.toRaw(e)).toString().trim();return!n.includes(" ")||n.startsWith("(")&&n.endsWith(")")||(n=`(${n})`),e.raw(`${n} ${"desc"===r.order.toLowerCase()?"desc":"asc"}`)})))}clearSchema(){this.datasetSchema=null}toDataset(){return this}selectItemsAlias(){if(!__privateGet(this,_selectItems))return[];const t=__privateGet(this,_selectItems);return Object.keys(t)}native(t){return this.nativeBuilderCallbacks=[],this.addNative(t),this}addNative(t){return this.nativeBuilderCallbacks.push(t),this}toDScalar(){return this.toDScalarWithArrayType()}toDScalarWithArrayType(){const t=new ArrayType(this.schema());return new DScalar(this,t,this.context)}toDScalarWithObjectType(){const t=new ObjectType(this.schema());return new DScalar(this,t,this.context)}toDScalarWithType(t){return t instanceof PropertyType?new DScalar(this,t,this.context):isFunction(t)?new DScalar(this,t(this),this.context):new DScalar(this,new t,this.context)}where(t){return this.baseWhere(t)}andWhere(t){const e=this.getWhere();if(void 0===e)return this.baseWhere(t);{const r=e,n=({And:e})=>e(r,t);return this.baseWhere(n)}}from(t){return this.baseFrom(t)}innerJoin(t,e){return this.baseInnerJoin(t,e)}leftJoin(t,e){return this.baseLeftJoin(t,e)}rightJoin(t,e){return this.baseRightJoin(t,e)}select(...t){if(0===t.length)throw new Error("select must have at least one argument");if(1===t.length&&(isScalarMap(t[0])||t[0]instanceof Function)){const e=t[0];this.clearSchema();const r=this.func2ScalarMap(e);return __privateSet(this,_selectItems,r),this}if(isArrayOfStrings(t)){const e=t;return this.clearSchema(),__privateSet(this,_selectItems,this.propNameArray2ScalarMap(e)),this}throw new Error("cannot handle unexpected arguments")}andSelect(...t){if(0===t.length)throw new Error("select must have at least one argument");if(1===t.length&&(isScalarMap(t[0])||t[0]instanceof Function)){const e=t[0];this.clearSchema();const r=this.func2ScalarMap(e);return __privateSet(this,_selectItems,Object.assign({},__privateGet(this,_selectItems),r)),this}if(isArrayOfStrings(t)){const e=t;return this.clearSchema(),__privateSet(this,_selectItems,Object.assign({},__privateGet(this,_selectItems),this.propNameArray2ScalarMap(e))),this}throw new Error("cannot handle unexpected arguments")}groupBy(...t){if(0===t.length)throw new Error("select must have at least one argument");if(1===t.length&&(isScalarMap(t[0])||t[0]instanceof Function)){const e=t[0],r=this.func2ScalarArray(e);return __privateSet(this,_groupByItems,r),this}if(isArrayOfStrings(t)){const e=t,r=this.propNameArray2ScalarMap(e);return __privateSet(this,_groupByItems,Object.keys(r).map((t=>r[t]))),this}}orderBy(...t){if(1!==t.length)throw new Error("must be one argument");const e=this.func2OrderItemArray(t[0]);return __privateSet(this,_orderByItems,e),this}limit(t){return __privateSet(this,_limit,t),this}offset(t){return __privateSet(this,_offset,t),this}datasource(t){return this.schema().datasource(t)}schema(){return this.datasetSchema||(this.datasetSchema=new DerivedTableSchema(this)),this.datasetSchema}selectItems(){return __privateGet(this,_selectItems)}async toSqlString(t){return(await this.toNativeBuilder(t)).toString()}async toNativeBuilder(t){const e=t??this.context;if(!e)throw new Error("There is no repository provided for dataset");const r=e.orm.getKnexInstance().clearSelect();if(r.then="It is overridden. Then function is removed to prevent execution when it is passing accross the async functions",!__privateGet(this,_selectItems)||0===Object.keys(__privateGet(this,_selectItems)).length)throw new Error("Not selectItems");if(this.fromItem){const t=await this.fromItem.toRaw(e);r.from(t)}if(await this.buildWhereClause(e,r),__privateGet(this,_offset)&&r.offset(__privateGet(this,_offset)),__privateGet(this,_limit)&&r.limit(__privateGet(this,_limit)),__privateGet(this,_selectItems)){const t=await this.queryScalarMap2RawArray(__privateGet(this,_selectItems),e,!0);if(0===t.length&&!this.fromItem)throw new Error("No SELECT and FROM are provided for Dataset");r.select(t)}if(__privateGet(this,_groupByItems)){const t=await this.queryScalarArray2RawArray(__privateGet(this,_groupByItems),e);if(0===t.length)throw new Error("No groupByItems");r.groupByRaw(t.map((t=>t.toString())).join(","))}if(__privateGet(this,_orderByItems)){const t=await this.orderByScalarArray2RawArray(__privateGet(this,_orderByItems),e);if(0===t.length)throw new Error("No groupByItems");r.orderByRaw(t.map((t=>t.toString())).join(","))}return await Promise.all(this.nativeBuilderCallbacks.map((async t=>{await t(r)}))),r}execute(t){const e=t??this.context;if(!e)throw new Error("There is no repository provided.");const r=this;return new DBQueryRunner(r,e,(async function(t){const e=await r.toNativeBuilder(this.context),n=await this.context.executeStatement(e,{},t);let s;if(this.context.client().startsWith("mysql"))s=n[0];else if(this.context.client().startsWith("sqlite"))s=n;else{if(!this.context.client().startsWith("pg"))throw new Error("Unsupport client.");s=n.rows}if(!Array.isArray(s))throw new Error("Unexpected.");const a=s.length,i=r.schema();await i.prepareForParsing(this.context);const o=new Array(a);for(let t=0;t<a;t++)o[t]=i.parseRaw(s[t],this.context);return o}))}};_selectItems=new WeakMap,_orderByItems=new WeakMap,_groupByItems=new WeakMap,_limit=new WeakMap,_offset=new WeakMap;var _updateItems,InsertStatement=class extends StatementBase{constructor(t,e){super(e),__privateAdd(this,_insertIntoSchema,void 0),__privateAdd(this,_insertItems,null),__privateSet(this,_insertIntoSchema,t)}values(t){let e;const r={},n=new ExpressionResolver2(r,void 0,[]);return t instanceof Function?(Object.assign(r,this.sqlKeywords(n)),e=t(Object.assign({},constructSqlKeywords(n,this.context)))):e=t,__privateSet(this,_insertItems,e.map((t=>Object.keys(t).reduce(((e,r)=>(e[r]=n.resolve(t[r]),e)),{})))),this}async toNativeBuilder(t){return this.toNativeBuilderWithSpecificRow(null,t)}async toNativeBuilderWithSpecificRow(t,e){const r=e??this.context;if(!r)throw new Error("There is no repository provided.");let n=r.orm.getKnexInstance().from(__privateGet(this,_insertIntoSchema).tableName(r));if(n.then="It is overridden. Then function is removed to prevent execution when it is passing accross the async functions",!__privateGet(this,_insertItems))throw new Error("No insert Items");const s=__privateGet(this,_insertIntoSchema).id.fieldName(r.orm),a=null===t?__privateGet(this,_insertItems):[__privateGet(this,_insertItems)[t]],i=await Promise.all(a.map((async t=>await this.scalarMap2RawMap(__privateGet(this,_insertIntoSchema),Object.assign({},t),r))));return n.insert(i),r.client().startsWith("pg")&&(n=n.returning(s)),n}getInsertItems(){return __privateGet(this,_insertItems)}execute(t){const e=t??this.context;if(!e)throw new Error("There is no repository provided.");const r=this;return new DBMutationRunner(e,(async function(t){if(!r.getInsertItems())throw new Error("Unexpected");return await this.context.startTransaction((async e=>{t={...t,trx:e};const n=await(async()=>{if(!this.latestQueryAffectedFunctionArg||this.context.client().startsWith("pg")){const e=(await r.toNativeBuilder(this.context)).toString(),n=await this.context.executeStatement(e,{},t);return this.context.client().startsWith("pg")?n.rows.map((t=>({id:t.id}))):null}if(this.context.client().startsWith("mysql")){let e;return await Promise.all(r.getInsertItems().map((async(n,s)=>{const a=(await r.toNativeBuilderWithSpecificRow(s,this.context)).toString(),i=await this.context.executeStatement(a,{},t);return e=i[0].insertId,{id:e}})))}if(this.context.client().startsWith("sqlite"))return await r.getInsertItems().reduce((async(e,n,s)=>{const a=await e,i=(await r.toNativeBuilderWithSpecificRow(s,this.context)).toString();await this.context.executeStatement(i,{},t);const o=await this.context.executeStatement("SELECT last_insert_rowid() AS id",{},t);return a.push({id:o[0].id}),a}),Promise.resolve([]));throw new Error("Unsupport client")})();if(this.latestQueryAffectedFunctionArg){const e=this.latestQueryAffectedFunctionArg,s=async()=>{const s=n,a=__privateGet(r,_insertIntoSchema),i=this.context.dataset().from(a.datasource("root")).where((({root:t})=>t.id.in(s.map((t=>t.id))))).select((({root:t})=>t.$allFields)),o=await e(i);return await o.execute().withOptions(t)};this.affectedResult=await s()}return n}),t.trx)}))}};_insertIntoSchema=new WeakMap,_insertItems=new WeakMap;var _updateItems2,UpdateStatement=class extends WhereClauseBase{constructor(t){super(t),__privateAdd(this,_updateItems,null)}from(t){return this.baseFrom(t)}where(t){return this.baseWhere(t)}innerJoin(t,e){return this.baseInnerJoin(t,e)}leftJoin(t,e){return this.baseLeftJoin(t,e)}rightJoin(t,e){return this.baseRightJoin(t,e)}set(t){let e;const r=this.getSelectorMap(),n=new ExpressionResolver2(r,this.fromItem,this.joinItems.map((t=>t.source)));if(t instanceof Function){const s=constructSqlKeywords(n,this.context),a=Object.assign({},r,s);e=t(a)}else e=t;return __privateSet(this,_updateItems,Object.keys(e).reduce(((t,r)=>(t[r]=n.resolve(e[r]),t)),{})),this}async toNativeBuilder(t){const e=t??this.context;if(!e)throw new Error("There is no repository provided.");if(!__privateGet(this,_updateItems))throw new Error("No update items");if(!this.fromItem)throw new Error("No from item");const r=await this.fromItem.toRaw(e);let n=e.orm.getKnexInstance().from(r);n.then="It is overridden. Then function is removed to prevent execution when it is passing accross the async functions",await this.buildWhereClause(e,n);const s=await this.scalarMap2RawMap(this.fromItem.schema(),__privateGet(this,_updateItems),e);if(0===Object.keys(s).length&&!this.fromItem)throw new Error("No UPDATE and FROM are provided for Dataset");if(n.update(s),e.client().startsWith("pg")){const t=this.fromItem.schema().id.fieldName(e.orm);n=n.returning(t)}return n}execute(t){const e=t??this.context;if(!e)throw new Error("There is no repository provided.");const r=this.fromItem.schema(),n=this;return new DBMutationRunner(e,(async function(t){return await this.context.startTransaction((async e=>{if(t={...t,trx:e},this.latestPreflightFunctionArg||this.latestQueryAffectedFunctionArg){const e=this.context.dataset();e.cloneFrom(n),e.select({...e.getFrom().$.$allFields});const s=this.latestPreflightFunctionArg?await this.latestPreflightFunctionArg(e):e;this.preflightResult=await s.execute().withOptions(t);const a=(this.preflightResult??[]).map((t=>t.id));if(await n.execute().withOptions(t),this.latestQueryAffectedFunctionArg)if(0===a.length)this.affectedResult=[];else{const e=this.context.dataset().from(r.datasource("root")).where((({root:t})=>t.id.in(...a))).select((({root:t})=>t.$allFields)),n=await this.latestQueryAffectedFunctionArg(e);this.affectedResult=await n.execute().withOptions(t)}return a}{const e=await n.toNativeBuilder(this.context),r=await this.context.executeStatement(e,{},t);return this.context.client().startsWith("pg")?r.rows.map((t=>t.id)):null}}),t.trx)}))}};_updateItems=new WeakMap;var _calculatedDefinition,_calculatedRaw,_lastContext,DeleteStatement=class extends WhereClauseBase{constructor(t){super(t),__privateAdd(this,_updateItems2,null)}from(t){return this.baseFrom(t)}where(t){return this.baseWhere(t)}innerJoin(t,e){return this.baseInnerJoin(t,e)}leftJoin(t,e){return this.baseLeftJoin(t,e)}rightJoin(t,e){return this.baseRightJoin(t,e)}async toNativeBuilder(t){const e=t??this.context;if(!e)throw new Error("There is no repository provided.");if(!this.fromItem)throw new Error("No from item");const r=await this.fromItem.toRaw(e);let n=e.orm.getKnexInstance().from(r);if(n.then="It is overridden. Then function is removed to prevent execution when it is passing accross the async functions",await this.buildWhereClause(e,n),n.delete(),e.client().startsWith("pg")){const t=this.fromItem.schema().id.fieldName(e.orm);n=n.returning(t)}return n}execute(t){const e=t??this.context;if(!e)throw new Error("There is no repository provided.");const r=this.fromItem.schema(),n=this;return new DBMutationRunner(e,(async function(t){return await this.context.startTransaction((async e=>{if(t={...t,trx:e},this.latestPreflightFunctionArg||this.latestQueryAffectedFunctionArg){const e=this.context.dataset();e.cloneFrom(n),e.select({...e.getFrom().$.$allFields});const s=this.latestPreflightFunctionArg?await this.latestPreflightFunctionArg(e):e;this.preflightResult=await s.execute().withOptions(t);const a=(this.preflightResult??[]).map((t=>t.id));if(await n.execute().withOptions(t),this.latestQueryAffectedFunctionArg){const e=this.context.dataset().from(r.datasource("root")).where((({root:t})=>t.id.in(...a))).select((({root:t})=>t.$allFields)),n=await this.latestQueryAffectedFunctionArg(e);this.affectedResult=await n.execute().withOptions(t)}return a}{const e=await n.toNativeBuilder(this.context),r=await this.context.executeStatement(e,{},t);return this.context.client().startsWith("pg")?r.rows.map((t=>Object.keys(t).map((e=>t[e]))[0])):null}}),t.trx)}))}};function isSQLStringWithArgs(t){const e=Object.keys(t);return!(1!==e.length||!e.includes("sql"))||!(2!==e.length||!e.includes("sql")||!e.includes("args"))}_updateItems2=new WeakMap;var _Scalar=class{constructor(t,e,r){this.context=null,__privateAdd(this,_calculatedDefinition,null),__privateAdd(this,_calculatedRaw,null),__privateAdd(this,_lastContext,null),e instanceof PropertyType?this.declaredDefinition=e:e&&(this.declaredDefinition=new e),this.expressionOrDataset=t,this.context=r??null}static value(...t){return"string"==typeof t[0]&&Array.isArray(t[1])?this.value({sql:t[0],args:t[1]},t[2]):new _Scalar(t[0],t[1])}static number(...t){return"string"==typeof t[0]&&Array.isArray(t[1])?this.number({sql:t[0],args:t[1]}):new _Scalar(t[0],NumberNotNullType)}isNull(){return new IsNullOperator(this.context,this).toScalar()}isNotNull(){return new IsNotNullOperator(this.context,this).toScalar()}looseEquals(t){return null==t?this.isNull():t instanceof DScalar?this.in(t):this.equals(t)}looseNotEquals(t){return null==t?this.isNotNull():t instanceof DScalar?this.notIn(t):this.notEquals(t)}equals(t){return new EqualOperator(this.context,this,resolveValueIntoScalar(t)).toScalar()}notEquals(t){return new NotEqualOperator(this.context,this,resolveValueIntoScalar(t)).toScalar()}like(t){return new LikeOperator(this.context,this,resolveValueIntoScalar(t)).toScalar()}notLike(t){return new NotLikeOperator(this.context,this,resolveValueIntoScalar(t)).toScalar()}in(...t){const e=1===t.length&&Array.isArray(t[0])?t[0]:t;return new InOperator(this.context,this,...e.map((t=>resolveValueIntoScalar(t)))).toScalar()}notIn(...t){const e=1===t.length&&Array.isArray(t[0])?t[0]:t;return new NotInOperator(this.context,this,...e.map((t=>resolveValueIntoScalar(t)))).toScalar()}greaterThan(t){return new GreaterThanOperator(this.context,this,resolveValueIntoScalar(t)).toScalar()}lessThan(t){return new LessThanOperator(this.context,this,resolveValueIntoScalar(t)).toScalar()}greaterThanOrEquals(t){return new GreaterThanOrEqualsOperator(this.context,this,resolveValueIntoScalar(t)).toScalar()}lessThanOrEquals(t){return new LessThanOrEqualsOperator(this.context,this,resolveValueIntoScalar(t)).toScalar()}between(t,e){return new BetweenOperator(this.context,this,resolveValueIntoScalar(t),resolveValueIntoScalar(e)).toScalar()}notBetween(t,e){return new NotBetweenOperator(this.context,this,resolveValueIntoScalar(t),resolveValueIntoScalar(e)).toScalar()}definitionForParsing(){return __privateGet(this,_calculatedDefinition)??this.declaredDefinition??new PropertyType}transform(t){return new _Scalar((e=>thenResult(this.resolveIntoRawOrDataset(e,this.expressionOrDataset),(r=>t(r,e)))))}async resolveDefinition(t,e){return thenResult(e,(e=>{if(e instanceof Dataset2)return this.resolveDefinition(t,e.toDScalarWithArrayType());if(e instanceof _Scalar){if(e.declaredDefinition)return e.declaredDefinition;{const r=e.expressionOrDataset;return this.resolveDefinition(t,r)}}return e instanceof Function?this.resolveDefinition(t,e(t)):new PropertyType}))}async calculateDefinition(t){const e=t??this.context;if(!e)throw new Error("There is no repository provided");return await this.resolveDefinition(e,this)}calculateRaw(t){const e=t??this.context;if(!e)throw new Error("There is no repository provided");const r=this.expressionOrDataset;return thenResult(this.getDefinition(e),(t=>thenResult(this.resolveIntoRawOrDataset(e,r),(r=>{if(r instanceof Dataset2)return(t??new PropertyType).transformQuery(r,e);{const n=e.raw(r.toString());return(t??new PropertyType).transformQuery(n,e)}}))))}resolveIntoRawOrDataset(t,e){return thenResult(e,(e=>e instanceof Dataset2?e:e instanceof _Scalar?this.resolveIntoRawOrDataset(t,e.expressionOrDataset):e instanceof Function?this.resolveIntoRawOrDataset(t,e(t)):"string"==typeof e?t.raw(e):isSQLStringWithArgs(e)?e.args?thenResultArray(e.args.map((e=>e instanceof _Scalar?e.toRaw(t):e instanceof Dataset2?e.toNativeBuilder(t):e)),(r=>thenResult(r,(r=>t.raw(e.sql,r))))):t.raw(e.sql):e))}async getDefinition(t){return t&&__privateGet(this,_lastContext)!==t&&__privateSet(this,_calculatedRaw,null),__privateGet(this,_calculatedDefinition)||(__privateSet(this,_calculatedDefinition,await this.calculateDefinition(t)),__privateSet(this,_lastContext,t??null)),__privateGet(this,_calculatedDefinition)}async toRaw(t){return t&&__privateGet(this,_lastContext)!==t&&__privateSet(this,_calculatedRaw,null),__privateGet(this,_calculatedRaw)||(__privateSet(this,_calculatedRaw,await this.calculateRaw(t)),__privateSet(this,_lastContext,t??null)),__privateGet(this,_calculatedRaw)}execute(t){const e=t??this.context;if(!e)throw new Error("There is no repository provided.");const r=this;return new DBQueryRunner(r,e,(async function(t){return(await this.context.dataset().select({root:r}).execute().withOptions(t))[0].root}))}},Scalar=_Scalar;_calculatedDefinition=new WeakMap,_calculatedRaw=new WeakMap,_lastContext=new WeakMap;var DScalar=class extends Scalar{constructor(t,e,r){super((async r=>{let n;return n=t instanceof Function?await t(r):t,n instanceof Dataset2&&!e?n.toDScalarWithType((t=>new ArrayType(t.schema()))):n}),e,r)}count(){return super.transform(((t,e)=>{if(t instanceof Dataset2)return t.select((()=>({count:new Scalar("Count(1)")}))).toDScalarWithType(NumberNotNullType);throw new Error("count is only applicable to Dataset.")}))}exists(){return super.transform(((t,e)=>{if(t instanceof Dataset2)return e.$.Exists(t);throw new Error("count is only applicable to Dataset.")}))}transform(t){return new DScalar((e=>thenResult(this.resolveIntoRawOrDataset(e,this.expressionOrDataset),(r=>t(r,e)))))}asArrayType(){return this.transform(((t,e)=>t.toDScalarWithType((t=>new ArrayType(t.schema())))))}asObjectType(){return this.transform(((t,e)=>t.toDScalarWithType((t=>new ObjectType(t.schema())))))}};function resolveValueIntoScalar(t){if(null===t)return new Scalar((t=>t.raw("?",[null])));if("boolean"==typeof t){const e=t;return new Scalar((t=>t.raw("?",[e])),new BooleanType)}if("string"==typeof t){const e=t;return new Scalar((t=>t.raw("?",[e])),new StringType)}if("number"==typeof t){const e=t;return new Scalar((t=>t.raw("?",[e])),new NumberType)}if(t instanceof Date){const e=t;return new Scalar((t=>t.raw("?",[e])),new DateTimeType)}return t instanceof ConditionOperator?t.toScalar():t instanceof Dataset2?t.toDScalarWithArrayType():t}var _entityName2,_repository,_schema,_model,_modelClass,_context,ExpressionResolver2=class{constructor(t,e,r){this.dictionary=t,this.fromSource=e,this.sources=r}resolve(t){let e;if(e=t instanceof Function?t(this.dictionary):t,(null===e||"boolean"==typeof e||"string"==typeof e||"number"==typeof e||e instanceof Date||e instanceof ConditionOperator||e instanceof Dataset2)&&(e=resolveValueIntoScalar(e)),e instanceof Scalar)return e;if(Array.isArray(e)){const t=new OrOperator(null,this,...e);return this.resolve(t)}if(this.fromSource&&e instanceof SimpleObjectClass){const t=e,r=Object.keys(t).reduce(((e,r)=>{let n=null,[s,a]=r.split(".");if(a?n=[this.fromSource,...this.sources?this.sources:[]].find((t=>t&&t.sourceAlias===s)):(a=s,n=this.fromSource),!n)throw new Error(`cannot found source (${s})`);const i=n.schema().propertiesMap[a];if(!i)throw new Error(`cannot found prop (${a})`);const o=(t,e)=>{const r=this.resolve(t);let n;return n=e instanceof AssertionOperatorWrapper?e.toScalar(t):null===e?new IsNullOperator(null,r).toScalar():new EqualOperator(null,r,this.resolve(e)).toScalar(),n};if(i instanceof FieldProperty||i instanceof ScalarProperty){const s=n.getFieldProperty(a);e.push(o(s,t[r]))}else if(i instanceof ComputeProperty){const s=n.getComputeProperty(a)();e.push(o(s,t[r]))}return e}),[]),n=new AndOperator(null,this,...r);return this.resolve(n)}throw new Error("Unsupport value")}},Model=class{constructor(t,e){__privateAdd(this,_entityName2,void 0),__privateAdd(this,_repository,void 0),__privateAdd(this,_schema,null),__privateSet(this,_repository,t),__privateSet(this,_entityName2,e)}get modelName(){return __privateGet(this,_entityName2)}field(t){return new FieldProperty(t instanceof FieldPropertyType?t:new t)}static compute(...t){return new ComputeProperty(new ComputeFunction2(t[0]))}static computeModelObject(t){return new ComputeProperty(new ComputeFunction2(t))}hook(t){}schema(){if(!__privateGet(this,_schema)){const t={};for(const e in this)this[e]instanceof Property&&(t[e]=this[e]);const e=Object.getOwnPropertyDescriptors(this.constructor.prototype);for(const r in e)e[r]instanceof Property&&(t[r]=e[r]);const r=new TableSchema(__privateGet(this,_entityName2),t,this.id);__privateSet(this,_schema,r)}return __privateGet(this,_schema)}datasource(t,e){return this.schema().datasource(t,e)}static hasMany(t,e,r="id"){return this.compute(((n,s)=>new DScalar((a=>{const i=a.getRepository(t),o=n.getFieldProperty(r),l=i.dataset(s);return l.andWhere((({root:t})=>o.equals(t.$allFields[e]))),l}))))}static belongsTo(t,e,r="id"){return this.compute(((n,s)=>new DScalar((a=>{const i=a.getRepository(t),o=n.getFieldProperty(e),l=i.dataset(s);return l.andWhere((({root:t})=>o.equals(t.$allFields[r]))),l})).asObjectType()))}static hasManyThrough(t,e,r,n,s,a="id"){return this.compute(((i,o)=>new DScalar((l=>{const c=l.getRepository(e),u=i.getFieldProperty(a),h=l.getRepository(t).datasource("through"),p=c.dataset((t=>{let e;o instanceof Function?o=o({through:h.$,...t}):e=o;const r={...e};if(r?.where instanceof Function){const t=r.where;r.where=e=>t({...e,through:h.$})}return r}));return p.innerJoin(h,(({And:t,through:e,root:a})=>t(e.$allFields[n].equals(a.$allFields[r]),e.$allFields[s].equals(u)))),p}))))}};_entityName2=new WeakMap,_repository=new WeakMap,_schema=new WeakMap;var ModelRepository=class{constructor(t,e,r){__privateAdd(this,_model,void 0),__privateAdd(this,_modelClass,void 0),__privateAdd(this,_context,void 0),__privateSet(this,_context,t),__privateSet(this,_modelClass,e),__privateSet(this,_model,new e(this,r))}get model(){return __privateGet(this,_model)}get modelClass(){return __privateGet(this,_modelClass)}get context(){return __privateGet(this,_context)}datasource(t,e){return __privateGet(this,_model).datasource(t,e)}schema(){return __privateGet(this,_model).schema()}createOne(t){return this.context.insert(__privateGet(this,_model).schema()).values([t]).execute().getAffectedOne()}createEach(t){return this.context.insert(__privateGet(this,_model).schema()).values(t).execute().getAffected()}findOne(t){return this.dataset(t).execute().getOne()}findOneOrNull(t){return this.dataset(t).execute().getOneOrNull()}find(t){return this.dataset(t).execute()}update(t,e){return this.context.update().set(t).from(__privateGet(this,_model).schema().datasource("root")).where(e??{}).execute().getAffected()}updateOne(t,e){return this.context.update().set(t).from(__privateGet(this,_model).schema().datasource("root")).where(e??{}).execute().getAffectedOne()}dataset(...t){if(1!==t.length)throw new Error("Wrong argument");const e=t[0],r=this.model.datasource("root"),n=this.context.dataset().from(r),s=r.getAllFieldProperty();let a;if(e&&(a=e instanceof Function?e({root:r.$,...this.context.$}):e),a?.where&&n.where(a.where),a?.selectProps&&n.select(...a.selectProps),a?.select){const t=a.select,e=Object.keys(t).map((e=>{const n=t[e];return{[e]:r.getComputeProperty(e)(n)}})).reduce(((t,e)=>Object.assign(t,e)),{});n.andSelect(Object.assign(s,e))}else n.andSelect(s);return a?.orderBy&&n.orderBy(a.orderBy),a?.offset&&n.offset(a.offset),a?.limit&&n.limit(a.limit),n}delete(t){return this.context.del().from(__privateGet(this,_model).schema().datasource("root")).where(t??{}).execute().getPreflight()}deleteOne(t){return this.context.del().from(__privateGet(this,_model).schema().datasource("root")).where(t??{}).execute().getPreflightOne()}};_model=new WeakMap,_modelClass=new WeakMap,_context=new WeakMap;var _globalKnexInstance,_contextMap,_ormConfig,_modelMap,_config,ComputeFunction2=class{constructor(t){this.fn=t}},ComputeFunctionDynamicReturn2=class extends ComputeFunction2{constructor(t){super(t),this.mode="dynamic"}},ORM=class{constructor(t){__privateAdd(this,_globalKnexInstance,null),__privateAdd(this,_contextMap,new Map),this.defaultORMConfig={models:{},knexConfig:{client:"mysql"}},__privateAdd(this,_ormConfig,void 0),__privateAdd(this,_modelMap,{});const e=Object.assign({},this.defaultORMConfig,t);__privateSet(this,_ormConfig,e),this.register()}get ormConfig(){return Object.assign({},__privateGet(this,_ormConfig))}get modelMap(){return __privateGet(this,_modelMap)}register(){if(__privateGet(this,_ormConfig).models){const t=__privateGet(this,_ormConfig).models;Object.keys(t).forEach((e=>{__privateGet(this,_modelMap)[e]=t[e]}))}__privateGet(this,_ormConfig).modelsPath&&fs.readdirSync(__privateGet(this,_ormConfig).modelsPath).forEach((t=>{if(t.endsWith(".js")){let e=__privateGet(this,_ormConfig).modelsPath+"/"+t;e=e.replace(/\.js$/,"");const r=e.split("/"),n=r[r.length-1],s=require(e),a=camelize(n),i=a.charAt(0).toUpperCase()+a.slice(1);__privateGet(this,_modelMap)[i]=s.default}}))}getContext(t){const e=JSON.stringify(t);let r=__privateGet(this,_contextMap).get(e);return r||(r=new DatabaseContext4(this,t),__privateGet(this,_contextMap).set(e,r)),r}getKnexInstance(){if(__privateGet(this,_globalKnexInstance))return __privateGet(this,_globalKnexInstance);const t=Object.assign({useNullAsDefault:!0},__privateGet(this,_ormConfig).knexConfig);if(void 0!==t.connection&&"object"!=typeof t.connection)throw new Error("Configuration connection only accept object.");if("string"!=typeof t.client)throw new Error("Configuration client only accept string");return t.connection=Object.assign({},t.connection,{multipleStatements:!0}),__privateSet(this,_globalKnexInstance,(0,import_knex.default)(t)),__privateGet(this,_globalKnexInstance)}async shutdown(){return this.getKnexInstance().destroy()}};_globalKnexInstance=new WeakMap,_contextMap=new WeakMap,_ormConfig=new WeakMap,_modelMap=new WeakMap;var DatabaseContext4=class{constructor(t,e){__privateAdd(this,_config,null),this.schemaSqls=()=>{const t=this.repos;return Object.keys(t).map((e=>t[e].model)).map((t=>t.schema().createTableStmt(this,{tablePrefix:this.tablePrefix}))).filter(notEmpty)},this.outputSchema=t=>{fs.writeFileSync(t,this.schemaSqls().join(";\n")+";")},this.createModels=async()=>{await Promise.all(this.schemaSqls().map((async t=>{await this.orm.getKnexInstance().raw(t)})))},this.executeStatement=async(t,e,r)=>{const n=t.toString();r?.onSqlRun&&r.onSqlRun(n);const s=this.orm.getKnexInstance().raw(n,e);r?.trx&&s.transacting(r.trx);let a=null;return a=await s,a},this.dataset=()=>new Dataset2(this),this.raw=(t,e)=>{const r=this.orm.getKnexInstance().raw(t,e??[]);return r.then="It is overridden. 'Then' function is removed to prevent execution when it is passing across any async function(s).",r},this.update=()=>new UpdateStatement(this),this.del=()=>new DeleteStatement(this),this.insert=t=>new InsertStatement(t,this),this.client=()=>this.orm.ormConfig.knexConfig.client.toString(),this.orm=t,__privateSet(this,_config,e??{}),this.repos=Object.keys(t.modelMap).reduce(((e,r)=>{const n=t.modelMap[r];return e[r]=new ModelRepository(this,n,r),e}),{})}get config(){return __privateGet(this,_config)}get tablePrefix(){return __privateGet(this,_config)?.tablePrefix??""}getRepository(t){if("string"==typeof t)return this.repos[t];{const e=Object.keys(this.repos).find((e=>this.repos[e].modelClass===t));if(!e)throw console.log("cannot find model",t),new Error("Cannot find model");return this.repos[e]}}scalar(...t){return"string"==typeof t[0]&&Array.isArray(t[1])?new Scalar({sql:t[0],args:t[1]},t[2],this):new Scalar(t[0],t[1],this)}get $(){const t={},e=new ExpressionResolver2(t);return Object.assign(t,constructSqlKeywords(e,this))}async startTransaction(t,e){const r=this.orm.getKnexInstance(),n=(e,r)=>thenResult(t(e),(async t=>(r||await e.commit(),t)),(async t=>{throw r||await e.rollback(),t}));if(e)return n(e,!0);{const t=await r.transaction();return await n(t,!1)}}};_config=new WeakMap;var DBActionRunnerBase=class{constructor(t,e){this.options={},this.context=t,this.execOptions={},this.action=e}async execAction(t){return await this.action.call(this,t??this.execOptions,this.options)}async then(t,e){try{const r=await this.execAction();return t?t(expandRecursively(r)):this.then(t,e)}catch(t){if(e)return e(t);throw t}}async exec(){return await this.execAction()}usingConnection(t){if(!t)throw new Error("No transaction given.");return this.execOptions.trx=t,this}usingConnectionIfAny(t){return t&&(this.execOptions.trx=t),this}onSqlRun(t){return this.execOptions.onSqlRun=t,this}withOptions(t){return this.execOptions=t,this}getOptions(){return this.execOptions}},DBQueryRunner=class extends DBActionRunnerBase{constructor(t,e,r,n){super(e,r),this.parent=null,this.parent=n?.parent??null,this.source=t}get ancestor(){let t=this;for(;t&&t.parent;)t=t.parent;return t||this}getOne(){return new DBQueryRunner(this.source,this.context,(async function(t,e){return await this.context.startTransaction((async r=>{t={...t,trx:r};const n=await this.ancestor.action.call(this,t,e);if(Array.isArray(n)){if(1!==n.length)throw new Error("getFirstOne finds Zero or Many Rows");return n[0]}throw new Error("Only array is allowed to use getFirstRow")}),t.trx)}),{parent:this})}getOneOrNull(){return new DBQueryRunner(this.source,this.context,(async function(t,e){return await this.context.startTransaction((async r=>{t={...t,trx:r};const n=await this.ancestor.action.call(this,t,e);if(Array.isArray(n)){if(n.length>1)throw new Error("getFirstOne finds Many Rows");return n[0]??null}throw new Error("Only array is allowed to use getFirstRow")}),t.trx)}),{parent:this})}getBuilder(){return this.source}},DBMutationRunner=class extends DBActionRunnerBase{constructor(t,e,r){super(t,e),this.preflightFunctionArg=null,this.queryAffectedFunctionArg=null,this.preflightResult=null,this.affectedResult=null,this.parent=null,this.parent=r?.parent??null,this.preflightFunctionArg=r?.preflightFunctionArg??null,this.queryAffectedFunctionArg=r?.queryAffectedFunctionArg??null}get ancestor(){let t=this;for(;t&&t.parent;)t=t.parent;return t||this}get latestPreflightFunctionArg(){let t=this;for(;t&&!t.preflightFunctionArg;)t=t.parent;return t?.preflightFunctionArg??null}get latestQueryAffectedFunctionArg(){let t=this;for(;t&&!t.queryAffectedFunctionArg;)t=t.parent;return t?.queryAffectedFunctionArg??null}async execAction(t){return await super.execAction(t)}withOptions(t){return super.withOptions(t),this}getOptions(){return this.execOptions}getAffected(...t){const e=t[0]??(t=>t);return new DBMutationRunner(this.context,(async function(t,e){return await this.ancestor.action.call(this,t,e),this.affectedResult}),{parent:this,queryAffectedFunctionArg:e})}getAffectedOne(...t){const e=t[0]??(t=>t);return new DBMutationRunner(this.context,(async function(t,e){return await this.context.startTransaction((async r=>{if(t={...t,trx:r},await this.ancestor.action.call(this,t,e),Array.isArray(this.affectedResult)){if(1!==this.affectedResult.length)throw new Error("getAffectedOne finds Zero or Many Rows");return this.affectedResult[0]}throw new Error("Only array is allowed to use getAffectedOne")}),t.trx)}),{parent:this,queryAffectedFunctionArg:e})}withAffected(...t){const e=t[0]??(t=>t);return new DBMutationRunner(this.context,(async function(t,e){return{result:await this.ancestor.action.call(this,t,e),preflight:this.preflightResult,affected:this.affectedResult}}),{parent:this,queryAffectedFunctionArg:e})}getPreflight(t){return new DBMutationRunner(this.context,(async function(t,e){return await this.ancestor.action.call(this,t,e),this.preflightResult}),{parent:this,preflightFunctionArg:t??(t=>t)})}getPreflightOne(t){return new DBMutationRunner(this.context,(async function(t,e){return await this.context.startTransaction((async r=>{if(t={...t,trx:r},await this.ancestor.action.call(this,t,e),Array.isArray(this.preflightResult)){if(1!==this.preflightResult.length)throw new Error("getPreflightOne finds Zero or Many Rows");return this.preflightResult[0]}throw new Error("Only array is allowed to use getPreflightOne")}),t.trx)}),{parent:this,preflightFunctionArg:t??(t=>t)})}withPreflight(t){return new DBMutationRunner(this.context,(async function(t,e){return{result:await this.ancestor.action.call(this,t,e),preflight:this.preflightResult,affected:this.affectedResult}}),{parent:this,preflightFunctionArg:t??(t=>t)})}},Hook2=class{constructor(t,e){this.name=t,this.action=e}onPropertyChange(t){return this.propName=t,this}};
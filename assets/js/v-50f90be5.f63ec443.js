"use strict";(self.webpackChunktaichi_orm=self.webpackChunktaichi_orm||[]).push([[886],{7292:(e,o,t)=>{t.r(o),t.d(o,{data:()=>n});const n={key:"v-50f90be5",path:"/playground.html",title:"Playground",lang:"en-US",frontmatter:{},excerpt:"",headers:[],filePathRelative:"playground.md",git:{updatedTime:1639074277e3,contributors:[{name:"Eddie Tang",email:"thfai2000@gmail.com",commits:1}]}}},6804:(e,o,t)=>{t.r(o),t.d(o,{default:()=>d});var n=t(6252),r=t(2262);const s=(0,n._)("h1",{id:"playground",tabindex:"-1"},[(0,n._)("a",{class:"header-anchor",href:"#playground","aria-hidden":"true"},"#"),(0,n.Uk)(" Playground")],-1),d={setup(e){const o=(0,r.Fl)((()=>({title:"Taichi ORM playground",modules:[{name:"sqlstring",url:"https://unpkg.com/sqlstring"},{name:"mysql2",url:"https://unpkg.com/mysql2"},{name:"knex",url:"https://unpkg.com/knex"},{name:"taichi-orm",url:"http://localhost:8080/taichi-orm/index.js"},{name:"fs",url:"https://unpkg.com/fake-fs"}],files:{"index.js":"\nconst { ORM, Model, PrimaryKeyType, StringType, StringNotNullType, DateType, NumberNotNullType } = require('taichi-orm')\n\n/*\n * Runkit doesn't support Class Properties\n * So we assign properties in constructor\n */\nclass ShopModel extends Model{\n  constructor(...args){\n    super(...args)\n    this.id = this.field(PrimaryKeyType)\n    this.name = this.field(new StringType({length: 100}))\n    this.products = ShopModel.hasMany(ProductModel, 'shopId')\n  }\n}\n\nclass ColorModel extends Model{\n  constructor(...args){\n    super(...args)\n    this.id = this.field(PrimaryKeyType)\n    this.code = this.field(new StringNotNullType({length: 50}))\n  }\n}\n\nclass ProductColorModel extends Model{\n  constructor(...args){\n    super(...args)\n    this.id = this.field(PrimaryKeyType)\n    this.productId = this.field(NumberNotNullType)\n    this.colorId = this.field(NumberNotNullType)\n    this.type = this.field(new StringNotNullType({length: 50}))\n  }\n}\n\nclass ProductModel extends Model{\n  constructor(...args){\n    super(...args)\n    this.id = this.field(PrimaryKeyType)\n    this.name = this.field(new StringType({length: 100}))\n    this.createdAt = this.field(DateType)\n    this.shopId = this.field(NumberNotNullType)\n    this.shop = ProductModel.belongsTo(ShopModel, 'shopId')\n    this.colors = ProductModel.hasManyThrough(ProductColorModel, ColorModel, 'id', 'colorId', 'productId')\n    //computed property created based on colors\n    this.colorsWithType = ProductModel.compute( (parent, type = 'main') => {\n      return parent.$.colors({\n        where: ({through}) => through.type.equals(type)\n      })\n    })\n  }\n}\n\n(async() =>{\n    // configure database\n    const orm = new ORM({\n        models: {\n          Shop: ShopModel, \n          Product: ProductModel, \n          Color: ColorModel, \n          ProductColor: ProductColorModel\n        },\n        knexConfig: {\n            client: 'mysql2'\n        }\n    })\n    try{\n\n      // create tables\n      await orm.getContext().createModels()\n      const { Shop, Product, Color, ProductColor } = orm.getContext().repos\n\n      // prepare the database\n      const [createdShop1, createdShop2] = await Shop.createEach([{name: 'Shop1'}, {name: 'Shop2'}])\n      const [createdProduct1] = await Product.createEach([\n        {name: 'Product1', shopId: createdShop1.id},\n        {name: 'Product2', shopId: createdShop2.id},\n        {name: 'Product3', shopId: createdShop2.id}\n      ])\n      const [createdColor1, createdColor2] = await Color.createEach([{code: 'red'}, {code: 'blue'}])\n      await ProductColor.createEach([\n        {productId: createdProduct1.id, colorId: createdColor1.id, type: 'main'},\n        {productId: createdProduct1.id, colorId: createdColor2.id, type: 'minor'}\n      ])\n      \n      // computed fields are the relations\n      // you can do complicated query in one go\n      // Graph-like selecting Models \"Shop > Product > Color\"\n      let records = await Shop.find({\n        select: {\n          products: {\n            select: {\n              colors: {\n                limit: 2\n              },\n              colorsWithType: 'main'\n            }\n          }\n        }\n      })\n  \n      console.log('Shop with related entities', records)\n  \n      // use computed fields for filtering\n      // for example: find all shops with Product Count is at least 2\n      let shopsWithAtLeast2Products = await Shop.find({\n        where: ({root}) => root.products().count().greaterThanOrEquals(2)\n      })\n  \n      console.log('Shops with at least 2 products', shopsWithAtLeast2Products)\n  \n      // Console.log the sql statements\n      await Shop.find({\n        selectProps: ['products']\n      }).onSqlRun(console.log)\n      \n\n    }finally{\n      await orm.shutdown()\n    }\n\n\n})()        \n            "}})));return(e,t)=>{const d=(0,n.up)("Playground");return(0,n.wg)(),(0,n.iD)(n.HY,null,[s,(0,n.Wm)(d,{parameters:(0,r.SU)(o)},null,8,["parameters"])],64)}}}}}]);
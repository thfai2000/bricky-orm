"use strict";(self.webpackChunktaichi_orm=self.webpackChunktaichi_orm||[]).push([[372],{7873:(e,t,a)=>{a.r(t),a.d(t,{data:()=>r});const r={key:"v-7012741b",path:"/guide/concepts/query-builder.html",title:"Query Builder",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"Scalar",slug:"scalar",children:[]},{level:2,title:"Dataset",slug:"dataset",children:[]},{level:2,title:"InsertStatement",slug:"insertstatement",children:[]},{level:2,title:"UpdateStatement",slug:"updatestatement",children:[]},{level:2,title:"DeleteStatement",slug:"deletestatement",children:[]}],filePathRelative:"guide/concepts/query-builder.md",git:{updatedTime:1638891041e3,contributors:[{name:"Eddie Tang",email:"thfai2000@gmail.com",commits:6}]}}},9054:(e,t,a)=>{a.r(t),a.d(t,{default:()=>d});const r=(0,a(6252).uE)('<h1 id="query-builder" tabindex="-1"><a class="header-anchor" href="#query-builder" aria-hidden="true">#</a> Query Builder</h1><p>Taichi Query Builder doesn&#39;t like <code>Knex.QueryBuilder</code>. It is more high-level in usage because it use the defined <code>Schema</code> and <code>Property</code> to build Query. It means that the actual table names and actual field names are abstracted and taken care by ORM. Besides, the <code>ComputeFunction</code> can be used in building your Query.</p><p>There are several kinds of <code>Query Builder</code></p><p>You can even use the <code>ComputeProperty</code></p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Although The Model API allows to use raw SQL, QueryBuilder is still necessary in some suitations:</p><ol><li>If you want to form unstructured records by joining two database tables, you need QueryBuilder. The common use case is producing metrics and reports. Model API form structured data that widely be used in building Restful API or GraphQL resolver.</li><li>Sometimes performance is critical. you need query builder to build optimised SQL (such as specifying Index Name).</li><li>Model.update() and Model.delete() will query the involved records before update or delete, and query the affected data again. But querybuilder allows to skip querying the affected records.</li></ol><h2 id="scalar" tabindex="-1"><a class="header-anchor" href="#scalar" aria-hidden="true">#</a> Scalar</h2><p>It represent a SQL single value with a specifc type like number, string or date. Dataset can be transformed into a Scalar. For example, &#39;SELECT count(*) FROM table1&#39; can act as a Scalar in number type.</p><h2 id="dataset" tabindex="-1"><a class="header-anchor" href="#dataset" aria-hidden="true">#</a> Dataset</h2><p>It is a query builder and represents the SELECT statement.</p><h2 id="insertstatement" tabindex="-1"><a class="header-anchor" href="#insertstatement" aria-hidden="true">#</a> InsertStatement</h2><h2 id="updatestatement" tabindex="-1"><a class="header-anchor" href="#updatestatement" aria-hidden="true">#</a> UpdateStatement</h2><h2 id="deletestatement" tabindex="-1"><a class="header-anchor" href="#deletestatement" aria-hidden="true">#</a> DeleteStatement</h2><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>The names of these operators and functions are first-letter captialized</p></div>',15),i={},d=(0,a(3744).Z)(i,[["render",function(e,t){return r}]])},3744:(e,t)=>{t.Z=(e,t)=>{const a=e.__vccOpts||e;for(const[e,r]of t)a[e]=r;return a}}}]);